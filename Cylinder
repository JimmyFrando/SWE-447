/* 
	Author: Jimmy Frando
	File Name: Cynlinder Object
	Date: 2/11/2016
	Description: This javascript file gives the code to create  a 3D cylinder using WebGL
*/


var Cylinder = 
{
	//object properties
	positions : 
	{ 
		numComponents : 3
	},

	indices : {},
	bottomCircle : {},
	topCircle : {},
	connectIndicies {},

	program : undefined,
	circlesConnectCount = 16,
	circlesDrawCount = 10,

	init : function() 
	{
		//the code to initialize our object. This will be called from the main
		//JS file's init method. 

		var numSidesCircle = 8;
		var dTheta = 2.0 * Math.PI / numSidesCircle

		positions = { 0.0, 0.0, 0.0 }; //initialize positions list with center point at origin
		indices = [ 0 ]; // initialize indicies list with center of triangle fan, or first vertex # to render

		//get indicies and vertexes for bottom circle
		for ( var i = 0; i < numSidesCircle; ++i ) 
		{
			var theta = i * dTheta;
			var x = Math.cos( theta ),
				y = Math.sin( theta ),
				z = 0.0;

			positions.push( x, y, z );
			indices.push( i + 1 );
			topCircle.push( i + 1 );
		}
		indices.push( 1 ); // Add first perimeters vertex to close the disk
		
		//Get indicies and vertexe for top circle
		positions.push( 0.0, 0.0, 1.0 ); //Add top cap center point of cylinder to list
		indices.push( 9 ) // Add top cap center indicy
		for ( var i = 0; i < numSidesCircle; ++i ) 
		{
			var theta = i * dTheta;
			var x = Math.cos( theta ),
				y = Math.sin( theta ),
				z = 1.0
				;

			positions.push( x, y, z );
			indices.push( i + 10 );
			bottomCircle.push( i + 10 );

		}

		indicies.push( 10 ); //Add first perimiter vertex to close top disk

		//Get Indicies for connecting the circles 
		for ( var i = 0; var <numSidesCircle; ++i )
		{
			connectIndicies.push( bottomCircle[i] )
			connectIndicies.push( topCircle[i] )
		}

		//Once done listing indices, initialize object's shader program
		this.program = initShaders( gl, "Cylinder-vertex-shader", "Cylinder-fragment-shader" );

		//Create a vertex buffer for vertex positions
		this.positions.buffer = gl.createBuffer();
		gl.bindBuffer( gl.ARRAY_BUFFER, this.positions.buffer );
		gl.bufferData( gl.ARRAY_BUFFER, new Float32Array( positions ), gl.STATIC_DRAW );

		//Create an indicies buffer for the indicies
		this.indices.buffer = gl.createBuffer();
		gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, this.indices.buffer );
		gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, new Uint16Array( indices ), gl.STATIC_DRAW );

		this.connectIndicies.buffer = gl.createBuffer();
		gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, this.connectIndicies.buffer );
		gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, new Uint16Array( connectIndicies ), gl.STATIC_DRAW );

		//Querys any vertex attribute locations from shader program
		this.positions.attribute = gl.getAttribLocation( this.program, "vPosition" );
	},

	draw : function () {
		// code to render our object including all of the necessary WebGL

		//Selects shader program we want to render (this one)
		gl.useProgram( this.program );

		//Binds and plumbs position attribute 
		gl.bindBuffer( gl.ARRAY_BUFFER, this.positions.buffer );
		gl.vertexAttribPointer( this.positions.attribute, this.positions.numComponents, gl.FLOAT, gl.FALSE, 0, 0 );
		gl.enableVertexAttrib( this.positions.attribute );
		gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, this.indices.buffer );
		gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, this.connectIndicies.buffer );

		//Render base circle
		var offset = 0;
		gl.drawElements( gl.TRIANGLE_FAN, this.circlesDrawCount, gl.UNSIGNED_SHORT, offset );

		//Render cap circle
		offset = 10 * 2;
		gl.drawElements( gl.TRIANGLE_FAN, this.circlesDrawCount, gl.UNSIGNED_SHORT, offset );

		//Render lines between circle caps 
		offset = 0;
		gl.drawElements( gl.LINES, this.circlesConnectCount, gl.UNSIGNED_SHORT, offset );
	},
};